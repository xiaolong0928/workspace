#Vue 基础知识

## nexttick原理
   在下次DOM更新结束之后延迟回调，nexttick主要使用了宏任务和微任务，根据执行环境分别采用如下：   
   * Promise
   * MutationObserver
   * setImmediate
   * 最后兜底的是setTimeout
   定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。

## vue2.x中如何监测数组变化
使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。

## Vue生命周期
* ```beforeCreate``` 是new Vue()之后触发的第一个钩子，在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问。   
* ```created``` 在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发updated函数。可以做一些初始数据的获取，在当前阶段无法与Dom进行交互，如果非要想，可以通过vm.$nextTick来访问Dom。
* ```beforeMount```发生在挂载之前，在这之前template模板已导入渲染函数编译。而当前阶段虚拟Dom已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发updated。
mounted在挂载完成后发生，在当前阶段，真实的Dom挂载完毕，数据完成双向绑定，可以访问到Dom节点，使用$refs属性对Dom进行操作。
* ```beforeUpdate``` 发生在更新之前，也就是响应式数据发生更新，虚拟dom重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。
* ```updated ```发生在更新完成之后，当前阶段组件Dom已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。
* ```beforeDestroy```发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。
* ```destroyed ```发生在实例销毁之后，这个时候只剩下了dom空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。

## computed 和 watch
```watch``` ：监听，执行数据的回调，如果监听的对象过于复杂的话，建议优化微监听字符串的形式   
```computed ```: 计算属性有缓存，当且仅当依赖的属性发生改变的时候才去重新计算，适用于比较耗性能的计算场景

## data必须的是函数
简单来说就是就是组件被复用多次，如果是对象的话，因为js对象是引用类型，所以会影响到全部的实例，所以必须得是函数

## Vue 模板编译原理
简单来讲就是吧template转化为render函数的过程，大概经历以下步骤：   
* 生成AST树
* 优化
* codegenerator   
首先解析模板，生成AST语法树，使用正则表达式对模板进行解析，对标签进行各种钩子函数处理。   
vue数据是响应式的，但是并不是所有的数据都是响应式的，有一些数据一旦渲染完毕之后就不会再变动了，对应的dom也不再变化，优化过程就是找到这些节点，进行标记，这些被标记的节点以后更新的时候就可以跳过比对，对运行时的代码优化起了很大作用。
最后一步就是将AST树转换为可执行的代码

## 虚拟DOM和key属性的作用
由于在浏览器中进行dom操作是很昂贵的，（为啥dom操作昂贵，因为跨流程通信和渲染线程触发的重新渲染，导致DOM操作慢），所以虚拟dom应运而生。   
vue2的Virtual DOM借鉴了开源库snabbdom的实现。
虚拟dom本质就是用js对象去描述dom节点，是对dom节点的抽象   
VirtualDOM映射到真实DOM要经历VNode的create、diff、patch等阶段。
key的作用是尽可能的复用dom

## Vue 通讯方式有
* 父子通讯：   
    父->子props，子->父 $on、$emit 获取父子组件实例 $parent、$children   
    Ref 获取实例的方式调用组件的属性或者方法   
    Provide、inject 官方不推荐使用，但是写组件库时很常用
* 兄弟之间通讯：   
   Event Bus 实现跨组件通信 Vue.prototype.$bus = new Vue Vuex，不过现在貌似都是Vuex
* 跨级通讯：   
    ```Vuex```    
    ```$attrs、$listeners```
    ```Provide、inject```

# vue 优化
* 编码阶段   
    - 尽量减少data中的数据，data中的数据都会增加getter-和setter，会收集对应的watcher    
    - v-if和v-for不能连用如果需要使用   
    - v-for给每项元素绑定事件时使用事件代理   
    - SPA 页面采用keep-alive缓存组件在更多的情况下，   
    - 使用v-if替代v-showkey保证唯一使用路由懒加载、异步组件   
    - 防抖、节流   
    - 第三方模块按需导入
    - 长列表滚动到可视区域动态加载   
    - 图片懒加载
* SEO优化
    - 预渲染
    - 服务端渲染
* 打包优化
    - 压缩代码
    - Tree Shaking/Scope Hoisting
    - 使用cdn加载第三方模块
    - 多线程打包happypack
    - splitChunks抽离公共文件
    - sourceMap优化
* 用户体验
    - 骨架屏
    - PWA
    - 还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。

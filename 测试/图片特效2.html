<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="./js/MarchingSquares.js"></script>
    <script src="./js/hidpi-canvas.js"></script>
</head>
<style>
    .box{
        display:flex;
        flex-wrap: wrap;
    }
   canvas{
       margin: 30px;
   }
    
</style> 
<body>
    <div class="box">
        <canvas id="canvas" width="320px" height="220px"></canvas>
         <canvas id="canvas2" width="320px" height="220px"></canvas>
        <!--<canvas id="canvas3" width="300px" height="200px"></canvas>
        <canvas id="canvas4" width="300px" height="200px"></canvas> -->
        
    </div>
    <script>
        // 企鹅图 http://res1.eqh5.com/FuL9srLAsfEUZr8-qqs25JrPoznw?imageMogr2/auto-orient
        function loadImg(src){
            const imgNode = new Image()
            imgNode.crossOrigin = 'anonymous'
            imgNode.src = src
            return new Promise((resolve,reject)=>{
                imgNode.onload = function(){
                    resolve(imgNode)
                }
            })
        }
        function drawOuttline(src,node){
            var ctx = node.getContext('2d');
            loadImg(src).then(imgNode=>{
                ctx.drawImage(imgNode, 10, 10, 300, 200);
                const imageData = ctx.getImageData(0,0,320,220)
                const path = recongizeImageData(imageData)
                console.log(path)
                // let resultPath = smoothPath(imageData,path)
                // fillPath(imageData,resultPath)
                // ctx.putImageData(imageData,0,0)
                calculatePath(path)

            })
        }
        // 把path 根据Y的不同 分成y个数组，每个数组找x不连续点 作为起始点
        function calculatePath(path){
            let transObj = {}
            let target=[]
            path.map(position=>{
                const y = position.y
                const x = position.x
                // transObj.y = []
                if(!transObj[y]){
                    transObj[y] = []
                }
                transObj[y].push(x)
            })
            // 遍历 transObj
            for(let y in transObj){
                const xArr = transObj[y]
                // 同一行连接 判断xArr 里面的点位是不是连续点 如果是连续点就连接起来
                let sameX = findSquenceNum(xArr)
                let currentSkipX = findSquenceSkipNum(xArr)
                for(let i =0;i<sameX.length/2;i++){
                    addTarget(target,sameX[i*2],y,sameX[i*2+1],y)
                }
                // 与上一行承接
                if(transObj[y-1]){
                    const lastXArr = transObj[y-1]
                    let lastSkipX = findSquenceSkipNum(lastXArr)
                    for(let i = 0 ;i<currentSkipX.length;i++){
                        const currentX = currentSkipX[i]
                        for(let j=0;j<lastSkipX.length;j++){
                            const lastX = lastSkipX[j]
                            if(currentX === las)
                        }
                    }
                }
            }
        }
        function findRelation(current,last,y){
            
        }
        function addTarget(target,x1,y1,x2,y2){
            target.push({
                start:{
                    x:x1,
                    y:y1
                },
                end:{
                    x:x2,
                    y:y2
                }
            })
        }
        // 找出数组中 顺序的数字 比如 [1,2,3,7,8,9] 返回[1,3,7,9] 如果没有返回空
        function findSquenceNum(arr){
            let target = []
            let first = arr[0]
            let last = arr[0]
            let j = 1
            for(let i=1;i<arr.length;i++){
                const val = arr[i]
                if(first + j === val){
                    last = val
                    j++
                } else {
                    if(last !== first){
                        target.push(first)
                        target.push(last)
                        first = val
                        last = val
                        j=1
                    }
                }
            }
            if(last !== first){
                target.push(first)
                target.push(last)
            }
            return target
        }
        // 去除该行中连续的数字 比如[1,2,3,7,8,9] 输出[1,3,7,9]
        function findSquenceSkipNum(arr){
            let target = [arr[0]]
            let final = arr[arr.length-1]
            for(let i=1;i<arr.length;i++){
                const current = arr[i]
                const last = arr[i-1]
                if(current-last !== 1){
                    if(target.indexOf(last) < 0){
                        target.push(last)
                    }
                    target.push(current)
                }
            }
            if(target.indexOf(final) < 0){
                target.push(final)
            }
            return target
        }
        // 平滑算法 填充路径 描边暂且设置为3px  搁置 暂且不用
        function smoothPath(imageData,path){
            const width = imageData.width
            const height = imageData.height
            let result = []
            let thick = 3
            path.map(position=>{
                const index = position.index
                if(position.y === 154){

                    if(position.type === 'up'){
                        for(let i =1;i<=thick;i++){
                            result.push(index-width*i)
                        }
                    } else if(position.type === 'up-right'){
                        for(let i =1;i<=thick;i++){
                            result.push(index-width*i+i)
                        }
                    }else if(position.type === 'right'){
                        for(let i =1;i<=thick;i++){
                            result.push(index+i)
                        }
                    }else if(position.type === 'right-down'){
                        for(let i =1;i<=thick;i++){
                            result.push(index+width*i+i)
                        }
                    }else if(position.type === 'down'){
                        for(let i =1;i<=thick;i++){
                            result.push(index+width*i)
                        }
                    }else if(position.type === 'down-left'){
                        for(let i =1;i<=thick;i++){
                            result.push(index+width*i-i)
                        }
                    }else if(position.type === 'left'){
                        for(let i =1;i<=thick;i++){
                            result.push(index-i)
                        }
                    }else if(position.type === 'up-left'){
                        for(let i =1;i<=thick;i++){
                            result.push(index-width*i-i)
                        }
                    }
                }
            })
            return result
        }
        // 填充路径 为红色
        function fillPath(imageData,path){
            path.map(index=>{
                imageData.data[index*4] = 255
                imageData.data[index*4+1] = 0
                imageData.data[index*4+2] = 0
                imageData.data[index*4+3] = 255
            })
            return imageData
        }
        // 识别图片轮廓 返回路径代码
        function recongizeImageData(imageData){
            // 每四个点描述一个像素
            let path = []
            const totalPixel = imageData.data.length/4
            const width = imageData.width
            const height = imageData.height
            for(let i=0;i<totalPixel;i++){
                // 遍历 找出边缘节点，如果是边缘节点 那么判断边缘节点类型 把对应的像素点加入路径数组
                let target = checkPixelIsEdge(imageData,i)
                if(target.state){
                    path.push({
                        index:i,
                        x:i%width,
                        y:Math.ceil(i/width),
                        type:target.type
                    })
                }
            }
            return path
        }
        // 检测像素是否是透明
        function checkPixelIsTransparent(imageData,index){
            let arr = imageData.data.slice(index*4,index*4+4)
            return arr.every(key=>key===0)
        }
        // 检测该像素是否是边缘像素
        function checkPixelIsEdge(imageData,index){
            // 找出该点的上下左右是否是透明
            const width = imageData.width
            const height = imageData.height
            const totalPixel = imageData.data.length/4
            let type = 'up'
            let state = false
            // 边界判断  不用判断边界  因为canvas 会把图片包裹一层
            const upPointState = checkPixelIsTransparent(imageData,index-width)
            const rightPointState = checkPixelIsTransparent(imageData,index+1)
            const downPointState = checkPixelIsTransparent(imageData,index+width)
            const leftPointState = checkPixelIsTransparent(imageData,index-1)
            // 判断八个方向
            /***
             * up-left      up       up-right 
             * left        center    right
             * down-left    down     right-down
             */
            // 如果上 为透明 其余都不是
            if(upPointState && !rightPointState && !downPointState && !leftPointState){
                // 说明这个边缘是上边为空
                type = 'up'
                state = true
            }
            // 如果上左为透明 其余不是
            if(upPointState && !rightPointState && !downPointState && leftPointState){
                // 说明这个边缘是上边为空
                type = 'up-left'
                state = true
            }
            // 如果上右为透明 其余不是
            if(upPointState && rightPointState && !downPointState && !leftPointState){
                // 说明这个边缘是上边为空
                type = 'up-right'
                state = true
            }
            // 如果右为透明 其余都不是
            if(!upPointState && rightPointState && !downPointState && !leftPointState){
                // 说明这个边缘是上边为空
                type = 'right'
                state = true
            }
            // 如果右下为透明 其余都不是
            if(!upPointState && rightPointState && downPointState && !leftPointState){
                // 说明这个边缘是上边为空
                type = 'right-down'
                state = true
            }
            // 如果下为透明 其余都不是
            if(!upPointState && !rightPointState && downPointState && !leftPointState){
                // 说明这个边缘是上边为空
                type = 'down'
                state = true
            }
            // 如果下左为透明 其余都不是
            if(!upPointState && !rightPointState && downPointState && leftPointState){
                // 说明这个边缘是上边为空
                type = 'down-left'
                state = true
            }
            // 如果下为透明 其余都不是
            if(!upPointState && !rightPointState && !downPointState && leftPointState){
                // 说明这个边缘是上边为空
                type = 'left'
                state = true
            }
            return {
                type,
                state
            }
        }
        drawOuttline('http://res1.eqh5.com/Fhtjv6-X1F95bSLMVVnCHTJDewib?imageMogr2/auto-orient',document.getElementById('canvas'))
        // drawOuttline('http://res1.eqh5.com/FuL9srLAsfEUZr8-qqs25JrPoznw?imageMogr2/auto-orient',document.getElementById('canvas2'))
    </script>
</body>
</html>